<?xml version="1.0" encoding="utf-8"?><testsuite errors="0" failures="1" name="pytest" skips="1" tests="3" time="0.868"><testcase classname="test_create_project.tavern.yaml" file="test_create_project.tavern.yaml" line="0" name="Create new project without modules" time="0.44454240798950195"></testcase><testcase classname="test_delete_project.tavern.yaml" file="test_delete_project.tavern.yaml" line="0" name="Deleate a created project" time="0.17338848114013672"><failure message="tavern.util.exceptions.TestFailError: Test &apos;Create project&apos; failed:
- Status code was 201, expected 2010">cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;
func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x110393510&gt;
when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

../virtual-environments/TavernVENV/lib/python3.7/site-packages/_pytest/runner.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

../virtual-environments/TavernVENV/lib/python3.7/site-packages/_pytest/runner.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = ()
kwargs = {&apos;item&apos;: &lt;YamlItem Deleate a created project&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

../virtual-environments/TavernVENV/lib/python3.7/site-packages/pluggy/hooks.py:284: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x10e64e2b0&gt;
hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/Users/cizquierdo/Jenkins/workspace/virtual-env...t 0x10f639be0&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10fde06d8&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem Deleate a created project&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

../virtual-environments/TavernVENV/lib/python3.7/site-packages/pluggy/manager.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/Users/cizquierdo/Jenkins/workspace/virtual-env...t 0x10f639be0&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10fde06d8&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem Deleate a created project&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

../virtual-environments/TavernVENV/lib/python3.7/site-packages/pluggy/manager.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/Users/cizquierdo/Jenkins/workspace/virtual-env...t 0x10f639be0&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10fde06d8&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem Deleate a created project&gt;}
firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

../virtual-environments/TavernVENV/lib/python3.7/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x10fe60eb8&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

../virtual-environments/TavernVENV/lib/python3.7/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/Users/cizquierdo/Jenkins/workspace/virtual-env...t 0x10f639be0&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10fde06d8&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem Deleate a created project&gt;}
firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

../virtual-environments/TavernVENV/lib/python3.7/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem Deleate a created project&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

../virtual-environments/TavernVENV/lib/python3.7/site-packages/_pytest/runner.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem Deleate a created project&gt;

    def runtest(self):
        self.global_cfg = self._parse_arguments()
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            verify_tests(self.spec)
    
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

../virtual-environments/TavernVENV/lib/python3.7/site-packages/tavern/testutils/pytesthook.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/Users/cizquierdo/Jenkins/workspace/Tavern/test_delete_project.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;Deleate a created project&apos;, &apos;marks&apos;: [&apos;Working&apos;, {&apos;usefixtures&apos;: [&apos;generate_name&apos;, &apos;generate_identifier..., &apos;headers&apos;: {&apos;X-Redmine-API-Key&apos;: &apos;{api_key}&apos;, &apos;Content-Type&apos;: &apos;{content_type}&apos;}}, &apos;response&apos;: {&apos;status_code&apos;: 200}}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;strict&apos;: [], &apos;variables&apos;: {&apos;api_key&apos;: &apos;c278b5e3cca993d48a760a...&apos;content_type&apos;: &apos;application/json&apos;, &apos;generate_identifier&apos;: &apos;brooke-mcmillan&apos;, &apos;generate_name&apos;: &apos;Brooke Mcmillan&apos;, ...}}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({
            &quot;env_vars&quot;: dict(os.environ),
        })
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        def stage_ids(s):
            return [i[&quot;id&quot;] for i in s]
    
        available_stages = test_block_config.get(&quot;stages&quot;, [])
    
        if test_spec.get(&quot;includes&quot;):
            # Need to do this separately here so there is no confusion between global and included stages
            for included in test_spec[&quot;includes&quot;]:
                for stage in included.get(&quot;stages&quot;, {}):
                    if stage[&quot;id&quot;] in stage_ids(available_stages):
                        msg = &quot;Stage id &apos;{}&apos; defined in stage-included test which was already defined in global configuration - this will be an error in future!&quot;.format(stage[&quot;id&quot;])
                        logger.warning(msg)
                        warnings.warn(msg, FutureWarning)
    
            included_stages = []
    
            for included in test_spec[&quot;includes&quot;]:
                if &quot;variables&quot; in included:
                    formatted_include = format_keys(included[&quot;variables&quot;], {&quot;tavern&quot;: tavern_box})
                    test_block_config[&quot;variables&quot;].update(formatted_include)
    
                for stage in included.get(&quot;stages&quot;, []):
                    if stage[&quot;id&quot;] in stage_ids(included_stages):
                        raise exceptions.DuplicateStageDefinitionError(
                            &quot;Stage with specified id already defined: {}&quot;.format(stage[&quot;id&quot;]))
                    included_stages.append(stage)
        else:
            included_stages = []
    
        available_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, available_stages)
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&apos;skip&apos;):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(&quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness)
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(&quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness)
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

../virtual-environments/TavernVENV/lib/python3.7/site-packages/tavern/core.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x10fe06b38&gt;}
stage = {&apos;name&apos;: &apos;Create project&apos;, &apos;request&apos;: {&apos;url&apos;: &apos;{protocol}://{host}/projects.json&apos;, &apos;method&apos;: &apos;POST&apos;, &apos;headers&apos;: {&apos;X-Re...ntifier}&apos;, &apos;description&apos;: &apos;asdasdasdasd&apos;}}}, &apos;response&apos;: {&apos;status_code&apos;: 2010, &apos;save&apos;: {&apos;body&apos;: {&apos;id&apos;: &apos;project.id&apos;}}}}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;BUILD_URL&apos;: &apos;http://localhost:8080/job/Tavern/12/&apos;, &apos;TERM_PROGRAM&apos;: &apos;Apple_Terminal&apos;, &apos;ANDROID_HO...aae98c8c81e108bb64f&apos;, &apos;Content-Type&apos;: &apos;application/json&apos;}, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;strict&apos;: [], &apos;variables&apos;: {&apos;api_key&apos;: &apos;c278b5e3cca993d48a760a...&apos;content_type&apos;: &apos;application/json&apos;, &apos;generate_identifier&apos;: &apos;brooke-mcmillan&apos;, &apos;generate_name&apos;: &apos;Brooke Mcmillan&apos;, ...}}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (list): List of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;)
    
        logger.info(&quot;Running stage : %s&quot;, name)
        response = r.run()
    
        verifiers = get_verifiers(stage, test_block_config, sessions, expected)
        for v in verifiers:
&gt;           saved = v.verify(response)

../virtual-environments/TavernVENV/lib/python3.7/site-packages/tavern/core.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.response.RestResponse object at 0x1102ed710&gt;
response = &lt;Response [201]&gt;

    def verify(self, response):
        &quot;&quot;&quot;Verify response against expected values and returns any values that
        we wanted to save for use in future requests
    
        There are various ways to &apos;validate&apos; a block - a specific function, just
        matching values, validating a schema, etc...
    
        Args:
            response (requests.Response): response object
    
        Returns:
            dict: Any saved values
    
        Raises:
            TestFailError: Something went wrong with validating the response
        &quot;&quot;&quot;
        # pylint: disable=too-many-statements
    
        self._verbose_log_response(response)
    
        self.response = response
        self.status_code = response.status_code
    
        try:
            body = response.json()
        except ValueError:
            body = None
    
        self._check_status_code(response.status_code, body)
    
        if self.validate_function:
            try:
                self.validate_function(response)
            except Exception as e: #pylint: disable=broad-except
                self._adderr(&quot;Error calling validate function &apos;%s&apos;:\n%s&quot;,
                    self.validate_function.func,
                    indent_err_text(traceback.format_exc()),
                    e=e)
    
        # Get any keys to save
        saved = {}
    
        redirect_query_params = self._get_redirect_query_params(response)
    
        saved.update(self._save_value(&quot;body&quot;, body))
        saved.update(self._save_value(&quot;headers&quot;, response.headers))
        saved.update(self._save_value(&quot;redirect_query_params&quot;, redirect_query_params))
    
        for cookie in self.expected.get(&quot;cookies&quot;, []):
            if cookie not in response.cookies:
                self._adderr(&quot;No cookie named &apos;%s&apos; in response&quot;, cookie)
    
        try:
            wrapped = get_wrapped_response_function(self.expected[&quot;save&quot;][&quot;$ext&quot;])
        except KeyError:
            logger.debug(&quot;No save function for this stage&quot;)
        else:
            try:
                to_save = wrapped(response)
            except Exception as e: #pylint: disable=broad-except
                self._adderr(&quot;Error calling save function &apos;%s&apos;:\n%s&quot;,
                    wrapped.func,
                    indent_err_text(traceback.format_exc()),
                    e=e)
            else:
                if isinstance(to_save, dict):
                    saved.update(to_save)
                elif to_save is not None:
                    self._adderr(&quot;Unexpected return value &apos;%s&apos; from $ext save function&quot;)
    
        self._validate_block(&quot;body&quot;, body)
        self._validate_block(&quot;headers&quot;, response.headers)
        self._validate_block(&quot;redirect_query_params&quot;, redirect_query_params)
    
        if self.errors:
&gt;           raise TestFailError(&quot;Test &apos;{:s}&apos; failed:\n{:s}&quot;.format(self.name, self._str_errors()), failures=self.errors)
E           tavern.util.exceptions.TestFailError: Test &apos;Create project&apos; failed:
E           - Status code was 201, expected 2010

../virtual-environments/TavernVENV/lib/python3.7/site-packages/tavern/_plugins/rest/response.py:207: TestFailError</failure></testcase><testcase classname="test_update_project.tavern.yaml" file="test_update_project.tavern.yaml" line="0" name="Modify project name" time="0.0004448890686035156"><skipped message="unconditional skip" type="pytest.skip">test_update_project.tavern.yaml:0: unconditional skip</skipped></testcase></testsuite>